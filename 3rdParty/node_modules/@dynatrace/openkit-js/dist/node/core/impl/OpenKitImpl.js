"use strict";
/*
 * Copyright 2019 Dynatrace LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpenKitImpl = void 0;
const BeaconSender_1 = require("../beacon/BeaconSender");
const CommunicationStateImpl_1 = require("../beacon/CommunicationStateImpl");
const BeaconCache_1 = require("../beacon/strategies/BeaconCache");
const LoggingUtils_1 = require("../logging/LoggingUtils");
const PayloadBuilder_1 = require("../payload/PayloadBuilder");
const StaticPayloadBuilder_1 = require("../payload/StaticPayloadBuilder");
const SequenceIdProvider_1 = require("../provider/SequenceIdProvider");
const SingleIdProvider_1 = require("../provider/SingleIdProvider");
const TimestampProvider_1 = require("../provider/TimestampProvider");
const CallbackHolder_1 = require("../utils/CallbackHolder");
const NullSession_1 = require("./null/NullSession");
const SessionImpl_1 = require("./SessionImpl");
const createIdProvider = (dcl) => dcl === 2 /* UserBehavior */
    ? new SequenceIdProvider_1.SequenceIdProvider()
    : new SingleIdProvider_1.SingleIdProvider(1);
/**
 * Implementation of the {@link OpenKit} interface.
 */
class OpenKitImpl {
    /**
     * Creates a new OpenKit instance with a copy of the configuration.
     *
     * @param config The app configuration.
     */
    constructor(config) {
        this.config = config;
        this.initCallbackHolder = new CallbackHolder_1.CallbackHolder();
        this.cache = new BeaconCache_1.BeaconCacheImpl();
        this.initialized = false;
        this.isShutdown = false;
        this.logger = config.openKit.loggerFactory.createLogger('OpenKitImpl');
        this.sessionIdProvider = createIdProvider(config.privacy.dataCollectionLevel);
        this.sessionConfig = Object.assign(Object.assign({}, config.privacy), config.openKit);
        this.applicationWidePrefix = StaticPayloadBuilder_1.StaticPayloadBuilder.applicationWidePrefix(this.config);
        this.beaconSender = new BeaconSender_1.BeaconSenderImpl(this, this.cache, config.openKit);
    }
    /**
     * Starts initialization of the OpenKit instance.
     * If an invalid response is sent back, we shutdown.
     */
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.debug('initialize');
            this.beaconSender.init();
        });
    }
    /**
     * @inheritDoc
     */
    shutdown(callback) {
        if (this.isShutdown) {
            return;
        }
        this.isShutdown = true;
        this.logger.debug('shutdown');
        this.beaconSender.shutdown().then(() => {
            // Wait for the beaconSender to resolve its shutdown
            // before notifying the shutdown callback.
            // This means all data has been sent and it is safe to
            // terminate the process.
            if (callback) {
                callback();
            }
        });
    }
    /**
     * @inheritDoc
     */
    createSession(clientIP = '') {
        // We always send the createSession-request to the server, even when DataCollectionLevel = Off, but no user
        // activity is recorded.
        if (this.isShutdown) {
            LoggingUtils_1.validationFailed(this.logger, 'createSession', 'OpenKit is already shutdown');
            return NullSession_1.defaultNullSession;
        }
        this.logger.debug('createSession', { clientIP });
        const sessionId = this.createSessionId();
        const sessionStartTime = TimestampProvider_1.defaultTimestampProvider.getCurrentTimestamp();
        const sessionPrefix = StaticPayloadBuilder_1.StaticPayloadBuilder.sessionPrefix(this.applicationWidePrefix, sessionId, clientIP, sessionStartTime);
        const communicationState = new CommunicationStateImpl_1.CommunicationStateImpl();
        const payloadBuilder = new PayloadBuilder_1.PayloadBuilder(communicationState);
        const session = new SessionImpl_1.SessionImpl(sessionId, payloadBuilder, sessionStartTime, this.sessionConfig);
        const cacheEntry = this.cache.register(session, sessionPrefix, payloadBuilder, communicationState);
        this.beaconSender.sessionAdded(cacheEntry);
        return session;
    }
    isInitialized() {
        return this.initialized;
    }
    waitForInit(callback, timeout) {
        // Trivial case: We already initialized and the waitForInit comes after initialization. We can resolve
        // immediately and synchronous.
        if (this.initialized || this.isShutdown) {
            callback(this.initialized);
            return;
        }
        if (timeout !== undefined) {
            // Init with timeout: We setup a timeout which resolves after X milliseconds. If the callback triggers,
            // we clear it, and check if the callback is still in the callback holder. If it is, it was not resolved,
            // so we can execute it, and remove it from the callback holder, so it can't get executed again.
            setTimeout(() => {
                if (this.initCallbackHolder.contains(callback)) {
                    callback(false);
                    this.initCallbackHolder.remove(callback);
                }
            }, timeout);
        }
        // Add the callback to the initCallbackHolder, so it gets resolved once the initialization fails or succeeds,
        // for both cases with and without timeout.
        this.initCallbackHolder.add(callback);
    }
    notifyInitialized(successfully) {
        this.initialized = true;
        this.initCallbackHolder.resolve(successfully);
        if (!successfully) {
            this.shutdown();
        }
    }
    _isShutdown() {
        return this.isShutdown;
    }
    _getBeaconSender() {
        return this.beaconSender;
    }
    _getPayloadCache() {
        return this.cache;
    }
    createSessionId() {
        return this.sessionIdProvider.next();
    }
}
exports.OpenKitImpl = OpenKitImpl;
//# sourceMappingURL=OpenKitImpl.js.map