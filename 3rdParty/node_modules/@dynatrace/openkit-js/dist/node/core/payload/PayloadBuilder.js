"use strict";
/*
 * Copyright 2019 Dynatrace LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PayloadBuilder = void 0;
const api_1 = require("../../api");
const WebRequestTracerImpl_1 = require("../impl/WebRequestTracerImpl");
const Payload_1 = require("./Payload");
const PayloadQueue_1 = require("./PayloadQueue");
const StaticPayloadBuilder_1 = require("./StaticPayloadBuilder");
class PayloadBuilder {
    constructor(commState) {
        this.commState = commState;
        this.queue = new PayloadQueue_1.PayloadQueue();
        this.listeners = [];
    }
    reportNamedEvent(name, actionId, sequenceNumber, timeSinceSessionStart) {
        if (this.isCaptureDisabled()) {
            return;
        }
        this._push(StaticPayloadBuilder_1.StaticPayloadBuilder.reportNamedEvent(name, actionId, sequenceNumber, timeSinceSessionStart));
    }
    reportCrash(errorName, reason, stacktrace, startSequenceNumber, timeSinceSessionStart) {
        if (this.isCaptureCrashesDisabled()) {
            return;
        }
        this._push(StaticPayloadBuilder_1.StaticPayloadBuilder.reportCrash(errorName, reason, stacktrace, startSequenceNumber, timeSinceSessionStart));
    }
    reportError(name, reason, errorValue, parentActionId, startSequenceNumber, timeSinceSessionStart) {
        if (this.isCaptureErrorsDisabled()) {
            return;
        }
        this._push(StaticPayloadBuilder_1.StaticPayloadBuilder.reportError(name, parentActionId, startSequenceNumber, timeSinceSessionStart, reason, errorValue));
    }
    reportValue(name, value, actionId, sequenceNumber, timeSinceSessionStart) {
        if (this.isCaptureDisabled()) {
            return;
        }
        this._push(StaticPayloadBuilder_1.StaticPayloadBuilder.reportValue(actionId, name, value, sequenceNumber, timeSinceSessionStart));
    }
    identifyUser(userTag, startSequenceNumber, timeSinceSessionStart) {
        if (this.isCaptureDisabled()) {
            return;
        }
        this._push(StaticPayloadBuilder_1.StaticPayloadBuilder.identifyUser(userTag, startSequenceNumber, timeSinceSessionStart));
    }
    action(name, actionId, startSequenceNumber, endSequenceNumber, timeSinceSessionStart, duration) {
        if (this.isCaptureDisabled()) {
            return;
        }
        this._push(StaticPayloadBuilder_1.StaticPayloadBuilder.action(name, actionId, startSequenceNumber, endSequenceNumber, timeSinceSessionStart, duration));
    }
    startSession(startSequenceNumber) {
        if (this.isCaptureDisabled()) {
            return;
        }
        this._push(StaticPayloadBuilder_1.StaticPayloadBuilder.startSession(startSequenceNumber));
    }
    endSession(startSequenceNumber, duration) {
        if (this.isCaptureDisabled()) {
            return;
        }
        this._push(StaticPayloadBuilder_1.StaticPayloadBuilder.endSession(startSequenceNumber, duration));
    }
    webRequest(url, parentActionId, startSequenceNumber, timeSinceSessionStart, endSequenceNumber, duration, bytesSent, bytesReceived, responseCode) {
        if (this.isCaptureDisabled()) {
            return;
        }
        const payload = StaticPayloadBuilder_1.StaticPayloadBuilder.webRequest(url, parentActionId, startSequenceNumber, timeSinceSessionStart, endSequenceNumber, duration, bytesSent, bytesReceived, responseCode);
        this._push(payload);
    }
    getNextPayload(prefix, transmissionTime) {
        if (this.queue.isEmpty()) {
            return undefined;
        }
        let payload = this.getCompletePrefix(prefix, transmissionTime);
        let remainingBeaconSize = this.commState.maxBeaconSize - payload.length;
        let next = this.queue.peek();
        while (next !== undefined && remainingBeaconSize - next.length > 0) {
            payload += '&' + this.queue.pop();
            remainingBeaconSize = this.commState.maxBeaconSize - payload.length;
            next = this.queue.peek();
        }
        return payload;
    }
    getWebRequestTracerTag(actionId, sessionNumber, sequenceNumber, deviceId, appId) {
        return WebRequestTracerImpl_1.createTag(actionId, sessionNumber, sequenceNumber, this.commState.serverId, deviceId, appId);
    }
    register(listener) {
        this.listeners.push(listener);
    }
    _push(payload) {
        this.queue.push(payload);
        this.listeners.forEach((listener) => listener.added(payload));
    }
    _getQueue() {
        return this.queue;
    }
    getCompletePrefix(prefix, transmissionTime) {
        const mutable = StaticPayloadBuilder_1.StaticPayloadBuilder.mutable(this.commState.multiplicity, transmissionTime);
        return Payload_1.combinePayloads(prefix, mutable);
    }
    isCaptureDisabled() {
        return this.commState.capture === api_1.CaptureMode.Off;
    }
    isCaptureErrorsDisabled() {
        return (this.commState.captureErrors === api_1.CaptureMode.Off ||
            this.isCaptureDisabled());
    }
    isCaptureCrashesDisabled() {
        return (this.commState.captureCrashes === api_1.CaptureMode.Off ||
            this.isCaptureDisabled());
    }
}
exports.PayloadBuilder = PayloadBuilder;
//# sourceMappingURL=PayloadBuilder.js.map