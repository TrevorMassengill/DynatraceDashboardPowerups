"use strict";
/*
 * Copyright 2019 Dynatrace LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SendingState = void 0;
const Utils_1 = require("../../../utils/Utils");
const HttpClient_1 = require("../HttpClient");
const HttpStatusResponse_1 = require("../HttpStatusResponse");
const HttpUrlBuilder_1 = require("../HttpUrlBuilder");
const OverloadPreventionState_1 = require("./OverloadPreventionState");
const timeouts = [1000, 2000];
const httpTooManyRequests = 429;
class SendingState {
    constructor(context) {
        this.context = context;
    }
    sendNewSessionRequest(url, request) {
        return __awaiter(this, void 0, void 0, function* () {
            const httpUrl = HttpUrlBuilder_1.buildHttpUrl(url, request, true);
            return this.retry(() => this.context.client.get(httpUrl));
        });
    }
    sendPayloadData(url, request, query) {
        return __awaiter(this, void 0, void 0, function* () {
            const httpUrl = HttpUrlBuilder_1.buildHttpUrl(url, request, false);
            return this.retry(() => this.context.client.post(httpUrl, query));
        });
    }
    sendStatusRequest(url, request) {
        return __awaiter(this, void 0, void 0, function* () {
            const httpUrl = HttpUrlBuilder_1.buildHttpUrl(url, request, false);
            return this.retry(() => this.context.client.get(httpUrl));
        });
    }
    /**
     * Retry the current request multiple times, and wait between retries.
     * If a status response with code 429 comes, change into the http429 - state.
     *
     * @param callback
     */
    retry(callback) {
        return __awaiter(this, void 0, void 0, function* () {
            {
                let response;
                let i = -1;
                do {
                    if (i !== -1) {
                        // Wait some milliseconds before retrying
                        yield Utils_1.timeout(timeouts[i]);
                    }
                    response = yield this.tryExecute(callback);
                    if (response.status === httpTooManyRequests) {
                        return this.handleHttpToManyRequests(response);
                    }
                    i++;
                } while (response.status !== 200 && i < timeouts.length);
                return new HttpStatusResponse_1.HttpStatusResponse(response, this.context.loggerFactory);
            }
        });
    }
    handleHttpToManyRequests(response) {
        this.context.stateMachine.setNextState(new OverloadPreventionState_1.OverloadPreventionState(this.context, response));
        // Return a valid response, but do not disable capturing, because this would shutdown the complete session,
        // and could not recover
        return { valid: true };
    }
    tryExecute(callback) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // We have to await here, in case the promise throws an exception
                return yield callback();
            }
            catch (_a) {
                return HttpClient_1.defaultInvalidHttpResponse;
            }
        });
    }
}
exports.SendingState = SendingState;
//# sourceMappingURL=SendingState.js.map